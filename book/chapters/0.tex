%%%%%%%%%%%
% Preface %
%%%%%%%%%%%
\chapter*{Preface}

\begin{chapquote}{Anyone who hates all the stupid quotes
at the beginning of each chapter}
``I hate all those stupid quotes at the beginning of each chapter.''
\end{chapquote}


Behind every text, however technical, there is a personal story of
its author\footnote{Even if the text was generated by a machine, and
the machine was designed by a computer program, and so on, this causal
chain eventually has its author.} and the author's motivations.

Having worked for a couple of months in an engineering company that
manufactured electronic equipment, I decided that perhaps it was the
best time to finish my education. So, I enrolled at the department of
Computer Science at the University of Gdańsk. Among other topics,
one lab was devoted to data processing heuristics jointly named 
``computational intelligence''.

Our first meeting was spent getting acquainted with the
programming language R that we were supposed to use throughout
the semester for the assignments. But I balked.

On the one hand, I've used many programming languages throughout my career:
JavaScript, Python, PHP, Perl, Bash, Matlab, SQL, C, C++, Assembly, Haskell,
Erlang, Prolog, Pascal, BASIC, VisualBasic, MiniKanren, and a few others. 
Some of those languages were really mind-expanding in their own unique ways.

On the other hand, being a rather seasoned Schemer, I knew that
most of these languages were only inferior incarnations of Lisp,
and I could find little value in learning a new syntactical disguise
for those well-established concepts.

I was very soon to find out that my skepticism was right, and that
learning R would require internalizing a lot of unfortunate
idiosyncrasies that the authors of the language had chosen for their
own reasons, and that I would be constantly stumbling over
those incomprehensible limitations and discrepancies between common
practices and the language developers' decisions. And for that
I didn't want to waste my time.

Bjarne Stroustrup said that there are only two kinds of languages:
the ones people complain about and the ones nobody uses\footnote{He
probably said that, because he was himself a creator of a popular
language that everybody complains about.}. The advocates of R sometimes
admit that perhaps the language isn't perfect, but it contains
a lot of convenient libraries to make the whole thing worthwhile.

Being a nobody, I was in a rather comfortable position, free
to decide if I want to complain on the language that I use or not.

I asked my TA whether he would allow me to choose
another language for doing the assignments, and he agreed.

My language of choice was of course Scheme, or -- more precisely --
Guile Scheme. I chose Guile because it has a wonderful trait:
rather than helplessly complain about features I don't like, I can
replace them with whatever I find more suitable. If a feature is
missing from the language, I can add it, rather than swear and curse
its developers.

The title of this pamphlet may suggest that it is written against
the R programming language, but it is actually written against the
majority of programming languages in use today\footnote{
However, the case of the R programming language is particularly
interesting, because initially it was just a harmless implementation
of Scheme; but then as a result of the irresponsible experiments
of mad scientists it mutated into a monster\cite{Ihaka2010}.}.
The ultimate goal of this text is to violently eliminate them all.

Recognizing that the aforementioned goal is rather quixotic, I will
be satisfied instead if anyone finds any value in
this pamphlet, whether it be education, entertainment or personal
hygiene\footnote{Concerns the printed copies}.

\section*{Structure of this pamphlet}
This pamphlet assumes no prior knowledge of programming.
If you think you already possess programming knowledge,
you'll probably see much that is new here.

Throughout the subsequent chapters, a large subset of the Scheme
programming language will be laid out, later chapters building
upon the earlier.
The first chapter introduces all the elementary notions needed
for programming in Scheme. The next two chapters show how to use that
knowledge in practice. The fourth chapter introduces a few
more features of the language that are used in the fifth
chapter.

Each chapter will introduce new definitions to be used
in later applications. For example, the third chapter presents
the notion of \texttt{equi\-valence\--classes} used
extensively throughout the fifth chapter.

The vision of programming presented here departs significantly
from the mainstream view, where a program is perceived
as a sequence of steps that lead us to a desired goal.

On the contrary, I intended to explain programs as
intellectual constructs of increasing complexity;
hence, reading the chapters in their proper sequence
is strongly recommended.

\section*{How to read this pamphlet}

The most essential part of this pamphlet are the definitions.
Everything else is just scaffolding whose purpose is to
facilitate their comprehension. The ultimate goal is to
make those definitions dance in the reader's head; hence
each definition should be studied with care. If there are
no examples given, it is up to the reader to come up
with proper examples, because if a definition is the
dance, then examples are the dancers.

The whole point of a definition is to create or express
a notion that can be further used to think about phenomena
in the world. Internalizing a definition is not always
a pleasant task, because it requires an intellectual
effort of focusing and remembering.

Reading programs isn't like reading novels. Because
of their familiar narrative specificity, we typically absorb
stories almost effortlessly. However, comprehending logical abstractions
requires a very different approach. Well written programs
are a bit like mathematical textbooks. The latter usually
consist mainly of definitions, examples, theorems and proofs
(and exercises).

The role of theorems is usually diminished in the realm
of computer programs: essential are the constructions,
the definitions. Examples (sometimes called \textit{unit
tests} by software folks) serve mainly as a means
of ensuring a program behaves as expected, which gains
importance as the program is subjected to changes.
Theorems manifest themselves in the weak form of \textit{assertions}
and \textit{type signatures}, while proofs are usually performed
by specific tools such as type checkers or model checkers.
Furthermore, false assertions can typically be refuted
during the execution of a program.

In the case of math textbooks, exercises and examples
are a way of facilitating comprehension. It is usually
much easier to understand an abstract definition if
we consider examples that are concrete instances of the abstract
definition.  Similarly, exercises are like examples but where some or
all of the reasoning is left out; as such, they can be thought of as
``partial examples'' where we are challenged to come up with the
reasoning for ourselves.

Reading a math textbook without doing the exercises is also
possible, but it is up to the reader to come up
with the deeper and broader understanding\footnote{
Programmers usually read computer programs in order
to change them, which is an ultimate exercise
in the comprehension of complex systems. On the
other hand, programs are often written with the
purpose of ``doing their job'', rather than
being comprehended and modified.

From my experience, this approach dominates,
not only in industry (which is understandable),
but also in education (which is harmful to industry).
}.

\section*{Who should read this pamphlet}

The title of this pamphlet may be misleading since readers
might think we are only concerned with computational methods.
Although there are certainly computational methods
involved, this work is really about thinking
and communicating thoughts.

While it is difficult to imagine anyone who would not benefit
from the knowledge presented here, there are some groups who
are particularly encouraged to do so. For instance, this text
may be of interest to philosophers and linguists, as it presents
a linguistic perspective on communicating thoughts
in a precise manner.

It may also be interesting to evolutionary biologists,
because it contains a quote from Richard Dawkins
and stuff like that.

It should be of particular interest to computer
scientists and programming language designers, to
convince them to \textit{stop designing new languages immediately!},
because -- as the history teaches us -- they often enough
succeed, thereby forcing generations of programmers to
suffer due to the ignorance of their creators.

However, as previously indicated, this book is about programming
\textit{and} clear thinking in equal measure, and
it is difficult to imagine someone who could not
benefit from this combination.

And so perhaps the shortest answer to the question posited
in the title of this section is: \textit{you}.

\section*{Acknowledgements}
Most of all, I would like to thank Grzegorz Madejski, the teaching
assistant who allowed me to go my own way,
and encouraged me to devote time to this project.
His classes were the source of all the examples presented in this text.

I am also truly grateful to my family and my girlfriend,
as they all encouraged me to go back to university. I certainly
couldn't have done it without their support.

I deeply appreciate the interest, support, feedback and
encouragement of my friends who allowed me to bother them with
the early versions of this text, and with whom I have had many
valuable and inspiring conversations, including Ścisław Dercz,
Hubert Melchert, Michał Janke, Marcin Jędruch, Jan Makulec
and Aleksander Mohuczy-Dominiak. 

I owe thanks to David Hashe, Robert Różański, Martin Clausen
and Dave Creelman for pointing out some errors and suggesting
improvements.

Last but not least, I owe thanks to Lawrence Bottorff and Rick Hanson,
who volunteered as the editors of this booklet.

\section*{Reporting bugs}

I realize that the quality of this text may be questionable.
After all, this is a pamphlet. However, if you find any parts
of the text obscure or difficult to understand, or if you
find any mistakes in the explanations presented here, or
simply want to talk about how miserable the world is, feel
free to write an e-mail to
\href{mailto:godek.maciek+pamphlet@gmail.com}{godek.maciek+pamphlet@gmail.com}.

Also make sure that you are reading the latest version
of this pamphlet, always available from

\url{https://panicz.github.io/pamphlet}

\noindent as many of the bugs may already have been fixed.

Finally, if you would like to become a co-author and add your
own chapters or examples, it will be my pleasure to merge your
pull-requests.
